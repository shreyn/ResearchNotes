## 1.1 What is Cryptography?
Cryptography is the mathematical science of designing secure communication systems in the presence of adversaries.
There are four different categories:
1. Confidentiality (the one we think of): ensuring only authorized parties can read info
2. Integrity: Ensuring data hasn't been tampered
3. Authentication: Proving the identity of the sender or receiver
4. Non-repudiation: Ensuring a sender cannot deny sending a message
#### Kerckhoffs's Principle
We must assume that the system itself is public, and only the key is private. 

- Cryptography: design of secure systems
- Cryptanalysis: study of breaking down these systems
## 1.4 Adversarial Models
1. Passive Adversary
	- Only listens, doesn't interfere
	- Goal is to learn plaintext from ciphertext
2. Active Adversary
	- Can intercept, modify, forge messages
	- Goal is to change the outcome of communication
Levels of Knowledge:
- Ciphertext-only attack (COA): Adversary only sees ciphertexts
- Known-plaintext attack (KPA): Adversary knows some plaintext–ciphertext pairs
- Chosen-plaintext attack (CPA): Adversary can choose plaintexts and get their ciphertexts
- Chosen-ciphertext attack (CCA): Adversary can choose ciphertexts and get their plaintexts (except for the challenge)
"Computationally Bounded":
- In modern cryptography, we assume the attacker can only run polynomial-time algorithms
- We want the system to be infeasible to break, not impossible
	- Contrasted with [[#1.6 Perfect Security]] (impossible to break)
## 1.5 Correctness and Basic Security Intuition
We cannot say a system is secure unless we can define and prove what it means to break it
### Private Key (Symmetric) Encryption
- A triple of algorithms: $$(\text{Gen, Enc, Dec)}$$
	1. Key Generation:
$$\text{Gen}(1^n)\rightarrow k$$
			- Input: a security parameter $n$, written in unary as $1^n$
			- Output: a random **key** $k \in K$
	2. Encryption:
$$\text{Enc}_k(m;r) \rightarrow c $$
			- Inputs: message $m \in M$, key $k \in K$, random bits $r \in R$ (optional but will explained later)
			- Output: ciphertext $c \in C$
			- Therefore, the same message $m$ encrypted multiple times may yield different ciphertexts
	3. Decryption:
							$$\text{Dec}_k(c) \rightarrow m \hspace{2em} \text{or} \perp$$
			- Inputs: ciphertext $c$, key $k$
			- Output: Either the original message $m$ or a special symbol $\perp$ meaning decryption failed.
				- Secure systems should return $\perp$ for malformed ciphertexts, otherwise, the attacker may learn something
### Correctness of an Encryption Scheme
We say a scheme (Gen, Enc, Dec) is correct if:
$$\forall k \in K , \forall m \in M, \forall r \in R, \hspace{1em} \text{Dec}_k(\text{Enc}_k(m;r)) = m$$
- Decrypting an encrypted message should return the original message, regardless of randomness used
### Why Deterministic Encryption is Insecure
Even if you can't decrypt, you can often still learn patterns.
- Attacker can create a table of pairs of ciphertext to plaintext
Therefore, secure encryption must not be deterministic
- Needs to include randomness, either internally (randomized encryption) or externally (via nonces or IVs)
## 1.6 Perfect Security
Suppose you send an encrypted message. If Eve intercepts and doesn't have the key, can she: Guess the message length? Infer the structure? Match to a previously seen message? If yes, then some information has leaked, even if she can't fully decrypt.
### Formal Definition (Shannon Secrecy)
Let:
- $M$ be a random variable of the message space $\mathcal{M}$
- $C$ be a random variable over the ciphertext space $\mathcal{C}$. 
- $k$ be the key generated by 
- $c= \text{Enc}_k(m)$  
An encryption scheme $(Gen, Enc, Dec)$ achieves **perfect secrecy** if:
$$\text{Pr}[M = m \hspace{0.5em} | \hspace{0.5em}C=c] = \text{Pr}[M = m] \hspace{1em} \forall m \in \mathcal M, c \in \mathcal C$$
- Learning the ciphertext does not change the adversary's belief about the probability of any message.
	- The **posterior belief** is the same as the **prior belief**
### One-Time Pad (OTP)
This provably achieves perfect secrecy, under some conditions.
Let messages, keys, and ciphertexts all be bitstrings of length $n$:
$$\mathcal M = \mathcal K = \mathcal C = \{0,1\}^n$$
- So keys are random, uniform, and used only once.
#### Key Generation: 
$$Gen(1^n) : \text{choose a key} \hspace{0.2em} k \in \{0,1\}^n \text{uniformly at random}$$
#### Encryption:
$$Enc_k(m) = c = m ⊕ k$$
- The ciphertext is the bitwise XOR of the message and the key.
#### Decryption:
$$Dec_k(c) = c ⊕ k = (m ⊕k)⊕k = m$$
- XORing twice with the same key cancels out
Therefore, $Dec_k(Enc_k(m)) = m$, so correctness is satisfied.

Why is this secure? 
- Suppose Eve knows the ciphertext. There is only one key that decrypts the ciphertext. 
- And since all keys are equally likely, all messages are equally likely. So posterior prob = prior prob.
#### Conditions:
1. Key is as long as the message
2. Key is uniformly random (no bias)
3. Key is used only once

There is a proof showing this acheives perfect secrecy, can add later.

### Why is Perfect Secrecy Infeasible?
If a scheme has perfect secrecy, then:
$$|\mathcal{K}| \geq |\mathcal M | $$
- The number of possible keys must be at least as large as the number of possible messages
Suppose you want to encrypt messages that are 1 megabyte long. Then you need a key size of 1 megabyte. This makes key distribution almost as hard as securely transmitting the message itself.
- Therefore, OTP is practically useless for most applications
Proof here about why if K < M, then not perfectly secret.

So perfect secrecy is great, but not feasible. Therefore, for modern cryptography, we relax the definition and accept that a system is secure if the adversary cannot break it within reasonable time (computational security).

